// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/// @title VulnerabilityScanner
/// @notice Library contract with static analysis functions for common vulnerabilities
/// @dev Provides gas-efficient vulnerability detection patterns for smart contracts
/// @author ChainGuard AI Team
library VulnerabilityScanner {
    /// @dev Convert bytes32 to string
    function bytes32ToString(bytes32 data) internal pure returns (string memory) {
        uint256 i;
        bytes memory result = new bytes(64);
        for (i = 0; i < 32; i++) {
            uint8 b = uint8(data[i]);
            uint8 hi = b >> 4;
            uint8 lo = b & 0x0f;
            result[2 * i] = bytes1(hi + (hi < 10 ? 48 : 87));
            result[2 * i + 1] = bytes1(lo + (lo < 10 ? 48 : 87));
        }
        return string(result);
    }
    
    /// @dev Vulnerability types enumeration
    enum VulnerabilityType {
        REENTRANCY,           // Reentrancy attacks
        UNCHECKED_RETURN,     // Unchecked external call returns
        INTEGER_OVERFLOW,      // Integer overflow/underflow
        ACCESS_CONTROL,        // Access control issues
        TX_ORIGIN_USAGE,       // Dangerous tx.origin usage
        UNPROTECTED_SELFDESTRUCT, // Unprotected selfdestruct
        DELEGATECALL_INJECTION,  // Delegatecall injection
        LOGIC_BOMB,           // Logic bombs / time locks
        FRONT_RUNNING,        // Front-running vulnerabilities
        GAS_LIMIT_ISSUES      // Gas limit and DoS vulnerabilities
    }
    
    /// @dev Vulnerability severity levels
    enum Severity {
        LOW,      // 1
        MEDIUM,   // 2
        HIGH,     // 3
        CRITICAL  // 4
    }
    
    /// @dev Struct to store vulnerability scan results
    struct ScanResult {
        VulnerabilityType vulnerabilityType;
        Severity severity;
        uint256 lineStart;
        uint256 lineEnd;
        string description;
        string recommendation;
        bool confirmed;
    }
    
    /// @dev Struct to store contract analysis results
    struct AnalysisResult {
        ScanResult[] vulnerabilities;
        uint256 totalVulnerabilities;
        uint256 criticalCount;
        uint256 highCount;
        uint256 mediumCount;
        uint256 lowCount;
        uint256 scanTimestamp;
        string contractHash;
    }
    
    /// @notice Analyze contract bytecode for reentrancy patterns
    /// @param bytecode Contract bytecode to analyze
    /// @return result Analysis result containing reentrancy vulnerabilities
    function analyzeReentrancy(bytes memory bytecode) 
        internal 
        view 
        returns (AnalysisResult memory result) 
    {
        result.scanTimestamp = block.timestamp;
        result.contractHash = bytes32ToString(keccak256(bytecode));
        
        // Check for call.value() patterns before state changes
        bytes4 callPattern = bytes4(keccak256("call.value(uint256)"));
        bytes4 transferPattern = bytes4(keccak256("transfer(address,uint256)"));
        bytes4 sendPattern = bytes4(keccak256("send(uint256)"));
        
        // Simplified pattern detection - in production, use more sophisticated analysis
        for (uint256 i = 0; i < bytecode.length - 4; i++) {
            bytes4 currentOp = bytes4(abi.encodePacked(bytecode[i], bytecode[i+1], bytecode[i+2], bytecode[i+3]));
            
            if (currentOp == callPattern || currentOp == transferPattern || currentOp == sendPattern) {
                // Found external call pattern - potential reentrancy
                result.totalVulnerabilities++;
                result.highCount++;
                break; // Simplified: just count one vulnerability for now
            }
        }
    }
    
    /// @notice Analyze contract for unchecked return values
    /// @param bytecode Contract bytecode to analyze
    /// @return result Analysis result containing unchecked return vulnerabilities
    function analyzeUncheckedReturns(bytes memory bytecode) 
        internal 
        view 
        returns (AnalysisResult memory result) 
    {
        result.scanTimestamp = block.timestamp;
        result.contractHash = bytes32ToString(keccak256(bytecode));
        
        // Check for external calls without return value checks
        bytes4[] memory dangerousCalls = new bytes4[](5);
        dangerousCalls[0] = bytes4(keccak256("call(bytes)"));
        dangerousCalls[1] = bytes4(keccak256("delegatecall(bytes)"));
        dangerousCalls[2] = bytes4(keccak256("staticcall(bytes)"));
        dangerousCalls[3] = bytes4(keccak256("transfer(address,uint256)"));
        dangerousCalls[4] = bytes4(keccak256("send(uint256)"));
        
        for (uint256 i = 0; i < bytecode.length - 4; i++) {
            bytes4 currentOp = bytes4(abi.encodePacked(bytecode[i], bytecode[i+1], bytecode[i+2], bytecode[i+3]));
            
            for (uint256 j = 0; j < dangerousCalls.length; j++) {
                if (currentOp == dangerousCalls[j]) {
                    result.totalVulnerabilities++;
                    result.mediumCount++;
                    break; // Simplified: just count one vulnerability
                }
            }
        }
    }
    
    /// @notice Analyze contract for access control issues
    /// @param bytecode Contract bytecode to analyze
    /// @return result Analysis result containing access control vulnerabilities
    function analyzeAccessControl(bytes memory bytecode) 
        internal 
        view 
        returns (AnalysisResult memory result) 
    {
        result.scanTimestamp = block.timestamp;
        result.contractHash = bytes32ToString(keccak256(bytecode));
        
        // Check for public/external functions without access control
        bytes4 selfdestructPattern = bytes4(keccak256("selfdestruct(address)"));
        bytes4 delegatecallPattern = bytes4(keccak256("delegatecall(bytes)"));
        
        for (uint256 i = 0; i < bytecode.length - 4; i++) {
            bytes4 currentOp = bytes4(abi.encodePacked(bytecode[i], bytecode[i+1], bytecode[i+2], bytecode[i+3]));
            
            if (currentOp == selfdestructPattern) {
                result.totalVulnerabilities++;
                result.criticalCount++;
            }
            
            if (currentOp == delegatecallPattern) {
                result.totalVulnerabilities++;
                result.highCount++;
            }
        }
    }
    
    /// @notice Analyze contract for tx.origin usage
    /// @param bytecode Contract bytecode to analyze
    /// @return result Analysis result containing tx.origin vulnerabilities
    function analyzeTxOriginUsage(bytes memory bytecode) 
        internal 
        view 
        returns (AnalysisResult memory result) 
    {
        result.scanTimestamp = block.timestamp;
        result.contractHash = bytes32ToString(keccak256(bytecode));
        
        // Check for tx.origin usage
        bytes32 txOriginPattern = keccak256("tx.origin");
        
        for (uint256 i = 0; i < bytecode.length - 32; i++) {
            bytes32 currentHash;
            assembly {
                currentHash := keccak256(add(bytecode, add(32, i)), 32)
            }
            
            if (currentHash == txOriginPattern) {
                result.totalVulnerabilities++;
                result.highCount++;
                break; // Simplified: just count one vulnerability
            }
        }
    }
    
    /// @notice Perform comprehensive vulnerability scan
    /// @param bytecode Contract bytecode to analyze
    /// @return result Complete analysis result with all vulnerability types
    function comprehensiveScan(bytes memory bytecode) 
        internal 
        view 
        returns (AnalysisResult memory result) 
    {
        result.scanTimestamp = block.timestamp;
        result.contractHash = bytes32ToString(keccak256(bytecode));
        
        // Run all analysis functions
        AnalysisResult memory reentrancyResult = analyzeReentrancy(bytecode);
        AnalysisResult memory uncheckedResult = analyzeUncheckedReturns(bytecode);
        AnalysisResult memory accessResult = analyzeAccessControl(bytecode);
        AnalysisResult memory txOriginResult = analyzeTxOriginUsage(bytecode);
        
        // Combine results
        result.totalVulnerabilities = reentrancyResult.totalVulnerabilities + 
                                     uncheckedResult.totalVulnerabilities + 
                                     accessResult.totalVulnerabilities + 
                                     txOriginResult.totalVulnerabilities;
        
        result.criticalCount = reentrancyResult.criticalCount + 
                               uncheckedResult.criticalCount + 
                               accessResult.criticalCount + 
                               txOriginResult.criticalCount;
        
        result.highCount = reentrancyResult.highCount + 
                          uncheckedResult.highCount + 
                          accessResult.highCount + 
                          txOriginResult.highCount;
        
        result.mediumCount = reentrancyResult.mediumCount + 
                            uncheckedResult.mediumCount + 
                            accessResult.mediumCount + 
                            txOriginResult.mediumCount;
        
        result.lowCount = reentrancyResult.lowCount + 
                         uncheckedResult.lowCount + 
                         accessResult.lowCount + 
                         txOriginResult.lowCount;
        
        // Combine vulnerability arrays
        uint256 totalVulns = result.totalVulnerabilities;
        result.vulnerabilities = new ScanResult[](totalVulns);
        
        uint256 index = 0;
        
        // Add reentrancy vulnerabilities
        for (uint256 i = 0; i < reentrancyResult.vulnerabilities.length; i++) {
            result.vulnerabilities[index] = reentrancyResult.vulnerabilities[i];
            index++;
        }
        
        // Add unchecked return vulnerabilities
        for (uint256 i = 0; i < uncheckedResult.vulnerabilities.length; i++) {
            result.vulnerabilities[index] = uncheckedResult.vulnerabilities[i];
            index++;
        }
        
        // Add access control vulnerabilities
        for (uint256 i = 0; i < accessResult.vulnerabilities.length; i++) {
            result.vulnerabilities[index] = accessResult.vulnerabilities[i];
            index++;
        }
        
        // Add tx.origin vulnerabilities
        for (uint256 i = 0; i < txOriginResult.vulnerabilities.length; i++) {
            result.vulnerabilities[index] = txOriginResult.vulnerabilities[i];
            index++;
        }
    }
    
    /// @notice Get vulnerability type as string
    /// @param vulnType Vulnerability type enum
    /// @return String representation of vulnerability type
    function getVulnerabilityTypeString(VulnerabilityType vulnType) 
        internal 
        pure 
        returns (string memory) 
    {
        if (vulnType == VulnerabilityType.REENTRANCY) return "REENTRANCY";
        if (vulnType == VulnerabilityType.UNCHECKED_RETURN) return "UNCHECKED_RETURN";
        if (vulnType == VulnerabilityType.INTEGER_OVERFLOW) return "INTEGER_OVERFLOW";
        if (vulnType == VulnerabilityType.ACCESS_CONTROL) return "ACCESS_CONTROL";
        if (vulnType == VulnerabilityType.TX_ORIGIN_USAGE) return "TX_ORIGIN_USAGE";
        if (vulnType == VulnerabilityType.UNPROTECTED_SELFDESTRUCT) return "UNPROTECTED_SELFDESTRUCT";
        if (vulnType == VulnerabilityType.DELEGATECALL_INJECTION) return "DELEGATECALL_INJECTION";
        if (vulnType == VulnerabilityType.LOGIC_BOMB) return "LOGIC_BOMB";
        if (vulnType == VulnerabilityType.FRONT_RUNNING) return "FRONT_RUNNING";
        return "GAS_LIMIT_ISSUES";
    }
    
    /// @notice Get severity as string
    /// @param severity Severity level enum
    /// @return String representation of severity level
    function getSeverityString(Severity severity) 
        internal 
        pure 
        returns (string memory) 
    {
        if (severity == Severity.LOW) return "LOW";
        if (severity == Severity.MEDIUM) return "MEDIUM";
        if (severity == Severity.HIGH) return "HIGH";
        return "CRITICAL";
    }
    
    /// @notice Get severity score (1-4)
    /// @param severity Severity level enum
    /// @return Numeric severity score
    function getSeverityScore(Severity severity) 
        internal 
        pure 
        returns (uint8) 
    {
        if (severity == Severity.LOW) return 1;
        if (severity == Severity.MEDIUM) return 2;
        if (severity == Severity.HIGH) return 3;
        return 4; // CRITICAL
    }
    
    /// @notice Calculate risk score for analysis result
    /// @param result Analysis result to score
    /// @return riskScore Overall risk score (0-100)
    function calculateRiskScore(AnalysisResult memory result) 
        internal 
        pure 
        returns (uint256 riskScore) 
    {
        // Weighted risk calculation
        riskScore = (result.criticalCount * 25) + 
                   (result.highCount * 15) + 
                   (result.mediumCount * 8) + 
                   (result.lowCount * 3);
        
        // Cap at 100
        if (riskScore > 100) riskScore = 100;
    }
    
    /// @notice Generate scan summary
    /// @param result Analysis result to summarize
    /// @return summary Human-readable summary of the scan
    function generateSummary(AnalysisResult memory result) 
        internal 
        pure 
        returns (string memory summary) 
    {
        // This would typically use a string library for concatenation
        // For simplicity, return a basic summary
        return "Scan completed with vulnerabilities detected";
    }
}
