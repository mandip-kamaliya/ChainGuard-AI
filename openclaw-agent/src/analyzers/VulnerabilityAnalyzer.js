/**
 * VulnerabilityAnalyzer â€” OpenAI GPT-4 powered smart contract security analysis
 *
 * Sends Solidity bytecode/source to OpenAI GPT-4 for OWASP Top 10
 * vulnerability detection. Returns structured vulnerability objects.
 */

import OpenAI from "openai";

const SECURITY_AUDIT_PROMPT = `You are ChainGuard AI, an expert Solidity smart contract security auditor.

Analyze the provided smart contract code for security vulnerabilities using the OWASP Smart Contract Top 10 framework and beyond.

CHECK FOR ALL OF THE FOLLOWING:

1. **Reentrancy Attacks** â€” External calls before state updates, cross-function reentrancy, read-only reentrancy
2. **Access Control Issues** â€” Missing modifiers, unprotected admin functions, improper role management
3. **Integer Overflow/Underflow** â€” Unchecked arithmetic (pre-Solidity 0.8), unsafe casting
4. **Unchecked External Calls** â€” Unchecked low-level call return values, silent failures
5. **tx.origin Usage** â€” Authentication via tx.origin instead of msg.sender (phishing vector)
6. **Timestamp Dependence** â€” Block.timestamp manipulation for critical logic
7. **Front-Running / MEV** â€” Predictable state changes exploitable by miners/searchers
8. **Denial of Service** â€” Unbounded loops, block gas limit issues, failed send blocking
9. **Bad Randomness** â€” On-chain randomness using blockhash, timestamp, etc.
10. **Delegate Call Injection** â€” Unsafe delegatecall to user-controlled addresses
11. **Flash Loan Vulnerabilities** â€” Price oracle manipulation, single-block exploits
12. **Signature Replay** â€” Missing nonces or chain ID in signed messages
13. **Storage Collision** â€” Proxy pattern storage layout issues
14. **Self-Destruct Abuse** â€” Force-sending ETH via selfdestruct
15. **Logic Errors** â€” Off-by-one, incorrect comparisons, wrong function visibility

RESPOND WITH ONLY a valid JSON array (no markdown, no backticks, no explanation) of vulnerability objects.
Each object must have:
{
  "id": "VULN-001",
  "title": "Short descriptive title",
  "severity": "CRITICAL" | "HIGH" | "MEDIUM" | "LOW",
  "category": "Category from list above",
  "description": "Detailed technical description of the vulnerability",
  "location": "Function name or line reference if identifiable",
  "impact": "What could happen if exploited",
  "recommendation": "Specific fix recommendation with code suggestions",
  "confidence": "HIGH" | "MEDIUM" | "LOW"
}

If no vulnerabilities are found, return an empty array: []

Important rules:
- Be thorough but avoid false positives â€” only flag real issues
- For bytecode-only analysis, use opcode pattern recognition
- Classify severity accurately: CRITICAL=funds at risk, HIGH=significant exploit, MEDIUM=potential issue, LOW=best practice
- Include specific fix recommendations
- Set confidence based on certainty of the finding`;

export class VulnerabilityAnalyzer {
    constructor(openaiClient) {
        // Accept either OpenAI client or API key
        if (openaiClient instanceof OpenAI) {
            this.client = openaiClient;
        } else {
            // Create new OpenAI client from API key in env
            this.client = new OpenAI({
                apiKey: process.env.ANTHROPIC_API_KEY || process.env.OPENAI_API_KEY,
            });
        }

        this.model = "gpt-4";
        this.analysisCount = 0;
    }

    /**
     * Analyze contract code for vulnerabilities
     * @param {string} code - Solidity source code or bytecode
     * @param {string} address - Contract address
     * @returns {Array} Structured vulnerability objects
     */
    async analyze(code, address) {
        this.analysisCount++;

        try {
            // Determine if this is source code or bytecode
            const isSource =
                code.includes("pragma solidity") ||
                code.includes("contract ") ||
                code.includes("function ");
            const codeType = isSource ? "Solidity source code" : "EVM bytecode";

            const userMessage = [
                `Analyze this ${codeType} for security vulnerabilities.`,
                `Contract address: ${address}`,
                "",
                "```solidity",
                code.length > 50000 ? code.slice(0, 50000) + "\n// ... truncated" : code,
                "```",
            ].join("\n");

            const completion = await this.client.chat.completions.create({
                model: this.model,
                messages: [
                    {
                        role: "system",
                        content: SECURITY_AUDIT_PROMPT,
                    },
                    {
                        role: "user",
                        content: userMessage,
                    },
                ],
                temperature: 0.1,
                max_tokens: 4096,
            });

            const responseText = completion.choices[0].message.content.trim();

            // Parse JSON response â€” handle potential markdown wrapping
            let cleaned = responseText;
            if (cleaned.startsWith("```")) {
                cleaned = cleaned
                    .replace(/^```(?:json)?\s*/i, "")
                    .replace(/\s*```\s*$/, "");
            }

            const vulnerabilities = JSON.parse(cleaned);

            if (!Array.isArray(vulnerabilities)) {
                console.warn("âš ï¸  OpenAI returned non-array response, wrapping");
                return [vulnerabilities];
            }

            // Validate and normalize each vulnerability
            return vulnerabilities
                .map((vuln, i) => this.normalizeVulnerability(vuln, i))
                .filter(Boolean);
        } catch (error) {
            console.error("OpenAI analysis error:", error.message);

            // Return a fallback for analysis failures
            if (error.message.includes("rate_limit") || error.status === 429) {
                console.warn("â³ Rate limited by OpenAI API, retrying in 30s...");
                await this.sleep(30000);
                return this.analyze(code, address);
            }

            return [
                {
                    id: "VULN-ERR",
                    title: "Analysis Incomplete",
                    severity: "MEDIUM",
                    category: "Analysis Error",
                    description: `Automated analysis could not be completed: ${error.message}`,
                    location: "N/A",
                    impact: "Unknown â€” manual review required",
                    recommendation: "Submit contract for manual security audit.",
                    confidence: "LOW",
                },
            ];
        }
    }

    /**
     * Normalize and validate a vulnerability object
     */
    normalizeVulnerability(vuln, index) {
        if (!vuln || typeof vuln !== "object") return null;

        const validSeverities = ["CRITICAL", "HIGH", "MEDIUM", "LOW"];
        const severity = validSeverities.includes(vuln.severity?.toUpperCase())
            ? vuln.severity.toUpperCase()
            : "MEDIUM";

        return {
            id: vuln.id || `VULN-${String(index + 1).padStart(3, "0")}`,
            title: vuln.title || "Unnamed Vulnerability",
            severity,
            category: vuln.category || "Unknown",
            description: vuln.description || "No description provided",
            location: vuln.location || "N/A",
            impact: vuln.impact || "Unknown impact",
            recommendation: vuln.recommendation || "Review and fix manually",
            confidence: ["HIGH", "MEDIUM", "LOW"].includes(
                vuln.confidence?.toUpperCase()
            )
                ? vuln.confidence.toUpperCase()
                : "MEDIUM",
        };
    }

    /**
     * Generate a human-readable Markdown report from vulnerabilities
     * @param {string} address - Contract address
     * @param {Array} vulnerabilities - Vulnerability array
     * @returns {string} Markdown report
     */
    generateReport(address, vulnerabilities) {
        const counts = {
            CRITICAL: vulnerabilities.filter((v) => v.severity === "CRITICAL").length,
            HIGH: vulnerabilities.filter((v) => v.severity === "HIGH").length,
            MEDIUM: vulnerabilities.filter((v) => v.severity === "MEDIUM").length,
            LOW: vulnerabilities.filter((v) => v.severity === "LOW").length,
        };

        const severityEmoji = {
            CRITICAL: "ðŸ”´",
            HIGH: "ðŸŸ ",
            MEDIUM: "ðŸŸ¡",
            LOW: "ðŸŸ¢",
        };

        let report = [
            `# Security Audit Report`,
            ``,
            `**Contract:** \`${address}\``,
            `**Scanner:** ChainGuard AI v1.0.0 (OpenAI GPT-4)`,
            `**Date:** ${new Date().toISOString()}`,
            ``,
            `## Summary`,
            ``,
            `| Severity | Count |`,
            `|----------|-------|`,
            `| ðŸ”´ Critical | ${counts.CRITICAL} |`,
            `| ðŸŸ  High | ${counts.HIGH} |`,
            `| ðŸŸ¡ Medium | ${counts.MEDIUM} |`,
            `| ðŸŸ¢ Low | ${counts.LOW} |`,
            `| **Total** | **${vulnerabilities.length}** |`,
            ``,
            `## Findings`,
            ``,
        ];

        vulnerabilities.forEach((vuln, i) => {
            report.push(
                `### ${i + 1}. ${severityEmoji[vuln.severity]} [${vuln.severity}] ${vuln.title}`,
                ``,
                `**Category:** ${vuln.category}`,
                `**Location:** ${vuln.location}`,
                `**Confidence:** ${vuln.confidence}`,
                ``,
                `**Description:**`,
                vuln.description,
                ``,
                `**Impact:**`,
                vuln.impact,
                ``,
                `**Recommendation:**`,
                vuln.recommendation,
                ``,
                `---`,
                ``
            );
        });

        return report.join("\n");
    }

    sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
}
